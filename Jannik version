import time
import random

from visualiser import ColourGraphics

import results
import entities
import parameters
from parameters import Simulation, World




# get koordinate correponding to an id number
# assumes that id number starts at 0.
def getCoordinate(id, grid: list[entities.Patch])->dir:
    """[summary]

    Args:
        id ([type]): [description]
        grid (list[list]): [description]

    Returns:
        [type]: [description]
    """
    corrd=grid[id].coordinates()
    return {"x": corrd[0], 
            "y": corrd[1]}


def buildWorld(parameters)->dir:
    """[summary]

    Args:
        parameters ([type]): [description]

    Returns:
        [type]: [description]
    """    
    # Build World!
    world_grid = []
    world_1d = []

    # Building grid
    for x in range(parameters.world.west_east_length):
        # Create a row for west to east in grid.
        row: list[entities.Patch] = []
        # add patches to row by height.
        for y in range(parameters.world.north_south_length):
            patch = entities.Patch(x, y)
            # reference variables is used to ensure both lists are updated and in sync with one another.
            world_1d.append(patch)
            row.append(patch)
        world_grid.append(row)

    # Populate World
    # out of total patches in world select samlpe == to total population size
    patchIds = random.sample(
        range(parameters.world.west_east_length * parameters.world.north_south_length),
        parameters.rabbits.initial_size + parameters.foxes.initial_size,
    )

    # contains ref. variable for all animals
    rabbits = []
    foxes = []

    # add animals
    for id in patchIds:
        # Add animal
        if len(rabbits) < parameters.rabbits.initial_size:
            rabbits.append(
                entities.Rabbit(
                    parameters.rabbits,
                    world_1d[id],
                    random.randint(0, parameters.rabbits.max_age),
                )
            )
            # skip iteration in loop.
        elif len(foxes) < parameters.foxes.initial_size:
            foxes.append(
                entities.Fox(
                    parameters.foxes,
                    world_1d[id],
                    random.randint(0, parameters.foxes.max_age),
                )
            )

    return {
        "world"     : world_grid,
        "world_1d"  : world_1d,
        "animals"   : rabbits + foxes,
        "animal_index" : [],
        "rabbits"   : rabbits,
        "foxes"     : foxes,
        "all_deads" : []
    }


# the grass grows, animal ages and the dead is collected.
def sleep(world_dir)-> dir:
    world_dir["animals"]    =[]
    for patch in world_dir.get("world_1d"):
        patch.tick()
        for animal in patch.animals():
            # used inheritance to reuse function for both species
            animal.tick()
            # The dead is collected in our woorld dictuanosjfbapuybdsf 
            if not animal.is_alive():
                world_dir["all_deads"].append(animal)
            elif animal.is_alive():
                world_dir["animals"].append(animal)
                
    return world_dir

def feed(world_dir)->dir:
    
    living_animals=[]

    for animal in world_dir["animals"]:
    # Rabbit, automatically eats grass
    # Fox, check for rabbits, if rabbit on same patch it gets eaten and killed.
        if type(animal) is entities.Fox : 
            animal.feed()
        if type(animal) is entities.Fox and animal.is_alive():
            living_animals.append(animal)
        elif type(animal) is entities.Fox:
            world_dir["all_deads"].append(animal)
            

        
    for animal in world_dir["animals"]:
    # Rabbit, automatically eats grass
    # Fox, check for rabbits, if rabbit on same patch it gets eaten and killed.
        if type(animal) is entities.Rabbit : 
            animal.feed()
        if type(animal) is entities.Rabbit and animal.is_alive():
            living_animals.append(animal)
        elif type(animal) is entities.Rabbit:
            world_dir["all_deads"].append(animal)
   
            

    world_dir["animals"]=living_animals 
    return world_dir

def Breeding(world_dir: dir,
    parameter:World,res)->list[entities.Animal]:
    animale_to_move=[]
    grid=world_dir.get("world")
    
    for animal in  world_dir["animals"]:
        if animal.can_reproduce():
            # get available patch
            validMovement = getNextPatch(animal,parameter)
            valid_coord = getValidPatches(validMovement, animal, grid, True)
            
            if(valid_coord):
                [x,y]=random.sample(valid_coord,1)[0]
                newborn = animal.reproduce(grid[x][y])
                if(newborn==None):
                    animale_to_move.append(animal)
                    if type(animal) is entities.Rabbit:
                        res.rabbits.total +=1
                    else:
                        res.foxes.total +=1
            else:
                animale_to_move.append(animal)
        else: 
            animale_to_move.append(animal)
    return animale_to_move, res


# for a given animal in a given world, find and evaluate next patches for movement.
def getNextPatch(
    animal      : entities.Animal,
    parameters  : World
    ):
    # Find legal patches
    [x,y] = animal.patch().coordinates()

    movableCoords = {
        "north" : [x, y + 1],
        "south" : [x, y - 1],
        "west"  : [x - 1, y],
        "east"  : [x + 1, y],
    }

    # movableCoords = [[-1,4],[0,3],[0,5]] # husk alle sider
    # ved len 5: [out of index on x], [ok], [out of index on y]
    validMovement = []

    if parameters.is_toroid:
        # snake world
        # each key in our dictionary do not support going around the grid more than once.
        for key in movableCoords:
            # [x,y] handles the x-axis and y-axis
            [x,y] = movableCoords[key]
            if x == parameters._west_east_length:
                x = 0
            if y == parameters._north_south_length:
                y = 0
            # collect valid patch coord.
            validMovement.append([x,y])
    else:
        # island world
        for key in movableCoords:
            # [x,y]
            [x,y] = movableCoords[key]
            # handles x-axis
            valid = True

            if x < 0 or x == parameters._west_east_length:
                valid = False
            # handles y-axis
            if y < 0 or y == parameters._north_south_length:
                valid = False

            if valid:
                validMovement.append([x,y])

    if len(validMovement) == 0:
        return []
    else:
        return validMovement


def getValidPatches(
    coords: list[list[int]],
    animal: entities.Animal,
    grid: list[list[entities.Patch]],
    breed: bool,
    ):
    validPatches = []
    for [x,y] in coords:
        
        patch: entities.Patch = grid[x][y]

        valid = True
        All_valid = True
       
        if type(animal) is entities.Rabbit and breed:
            if patch._has_alive_fox():
                All_valid = False
            if patch._has_alive_rabbit():
                valid = False
        elif type(animal) is entities.Rabbit:
            if patch._has_alive_rabbit():
                valid = False
        elif type(animal) is entities.Fox:
            if patch._has_alive_fox():
                valid = False

        if not All_valid:
            return []
        if valid:
            validPatches.append([x,y])
        

    return validPatches


def Move_animals(
    animale_to_move: list[entities.Animal],
    grid: list[list[entities.Patch]],
    parameters: World
    ):
    for animal in animale_to_move:
        validMovement = getNextPatch(animal,parameters)
        valid_coord = getValidPatches(validMovement, animal, grid, False)

        if valid_coord:
            [x,y]=random.sample(valid_coord,1)[0]
            animal.move_to(grid[x][y])


def rabbitsYouKnow():
    for times in range(7):
        print(
                """
    Reproducing, please wait..
        \\\\
    \\\\_   \\\\
    (')    \\\\_
    / )=.---(')
    o( )o( )_-\_ )"""
        )
        time.sleep(0.1)
        print(chr(27) + "[2J")

        print(
                """
    Reproducing, please wait...
        \\\\
    \\\\_     \\\\
    (')      \\\\_
    / )=  .---(')
    o( )o  ( )_-\_ )"""
        )

        time.sleep(0.1)
        print(chr(27) + "[2J")

def list_to_grid(list_1: list,colum: int)->list:
    
    grid_1 = [list_1[x:x+colum] for x in range(0, len(list_1), colum)]
    return grid_1

def dead_animals(world,res)->results.SimulationStats:

    for animal in world["all_deads"]:

        if type(animal) is entities.Rabbit:
            if animal.was_killed():
                res.rabbits.age_at_death.append(animal.age())
                res.rabbits.dead_by_predation += 1

                # Getting the coordinats where the rabbit was killed
                [x,y]=animal.patch().coordinates()
                res.kills_per_patch[x][y] += 1
            elif animal.energy()==0:
                res.rabbits.age_at_death.append(animal.age())
                res.rabbits.dead_by_starvation += 1
            else:
                res.rabbits.age_at_death.append(animal.age())
                res.rabbits.dead_by_old_age += 1
        else:
            if animal.energy()==0:
                res.foxes.age_at_death.append(animal.age())
                res.foxes.dead_by_starvation += 1
            else:
                res.foxes.age_at_death.append(animal.age())
                res.foxes.dead_by_old_age += 1
    return res

def alive_animals(world,res)->results.SimulationStats:
    energy_rab=0
    energy_rab_num=0

    energy_fox=0
    energy_fox_num=0
    for animal in world.get("animals"):
        if type(animal) is entities.Rabbit:
            energy_rab += animal.energy()
            energy_rab_num +=1
        else:
            energy_fox += animal.energy()
            energy_fox_num +=1


    res.rabbits.size_per_step.append(energy_rab_num)
    res.foxes.size_per_step.append(energy_fox_num)    

    if energy_rab_num!=0:
        res.rabbits.avg_energy_per_step.append(round(energy_rab/energy_rab_num,2))
    else:
        res.rabbits.avg_energy_per_step.append(0)
    if energy_fox_num!=0:
        res.foxes.avg_energy_per_step.append(round(energy_fox/energy_fox_num,2))
    else:
        res.foxes.avg_energy_per_step.append(0)

    if res.rabbits.avg_energy_per_step[-1]==0 and res.foxes.avg_energy_per_step[-1]==0:
        res.avg_energy_per_step.append(0)
    elif res.rabbits.avg_energy_per_step[-1]==0:
        res.avg_energy_per_step.append(res.foxes.avg_energy_per_step[-1])
    elif res.foxes.avg_energy_per_step[-1]==0:
        res.avg_energy_per_step.append(res.rabbits.avg_energy_per_step[-1])
    else:
        res.avg_energy_per_step.append(round((res.rabbits.avg_energy_per_step[-1]+res.foxes.avg_energy_per_step[-1])/2,2))

    return res

def print_theshit(res):
    print("A record of the age of death of each individual.")
    print(res.foxes.age_at_death)     #
    print(res.rabbits.age_at_death)
    
          
    print("\n")
    print("A record of the average energy level across the population, in chronological order.")
    print(res.foxes.avg_energy_per_step)       #
    print(res.rabbits.avg_energy_per_step)#
    print(res.avg_energy_per_step)
          
    print("\n")
    print("Number of individuals that died by old age.")
    print(res.foxes.dead_by_old_age)     #
    print(res.rabbits.dead_by_old_age)       #
    
          
    print("\n")
    print("Number of individuals that died by predation.")
    print(res.rabbits.dead_by_predation)#
    
          
    print("\n")
    print(" Number of individuals that died by starvation.")
    print(res.foxes.dead_by_starvation)       #
    print(res.rabbits.dead_by_starvation)       #
    
    print("\n")
    print("A record of the size of the (alive) population, in chronological order.")
    print(res.foxes.size_per_step)
    print(res.rabbits.size_per_step)
    
    print("\n")
    print("Individuals alive and ever lived")
    print(res.foxes.total)       #
    print(res.rabbits.total)       #
    
    
    print("\n")
    print("A grid containing the total of deaths by predation per every patch in the simulation.")
    print(res.kills_per_patch)

def run(parameters: Simulation):
    """
    Runs a simulation with the given parameters and returns the data collected.
    """
    # checks that preconditions on parameters are met
    print(" Checking parameters...", end="")
    assert 0 < parameters.world.north_south_length
    assert 0 < parameters.world.west_east_length
    assert 0 <= parameters.rabbits.initial_size <= parameters.world.area()
    assert 0 <= parameters.foxes.initial_size <= parameters.world.area()
    assert 0 <= parameters.rabbits.reproduction_probability <= 1
    assert 0 <= parameters.foxes.reproduction_probability <= 1
    assert 0 <= parameters.rabbits.metabolism
    assert 0 <= parameters.foxes.metabolism
    print("everything is ok.")

    # the rest is for faking some computation using time.sleep while
    # displaying some progress indicator.

    # Build World and Popoulate World
    world = buildWorld(parameters)
    parameters.execution.max_steps=10

    cg = ColourGraphics(
        parameters.execution.max_steps,
        world.get("world_1d"),
        parameters.world.west_east_length,
        parameters.world.north_south_length,
        0.1
        )
    ## rabbits dont stack, foxes dont stack, foxes stacks rabbits

    res = results.SimulationStats()
    alive_animals(world,res)
    res.rabbits.total = parameters.rabbits.initial_size 
    res.foxes.total = parameters.foxes.initial_size 

    kill_list=[0]*parameters.world.west_east_length*parameters.world.north_south_length
    kill_grid=list_to_grid(kill_list,parameters.world.north_south_length)
    res.kills_per_patch=kill_grid

    cg.start()
    # Per tick
    tick=0
    while len(world.get("animals"))!=0 and tick < parameters.execution.max_steps:
        cg.update(tick)

        world                   = sleep(world)
        world                   = feed(world)

        [Moveable_animals,res]  = Breeding(world,parameters.world,res)
        Move_animals(Moveable_animals, world.get("world"), parameters.world)
        res = alive_animals(world,res)
        tick += 1

    res = dead_animals(world,res)
    cg.stop()

    res.steps=tick

    print("simulation Complete")
    print_theshit(res)
    print(len(world["all_deads"]))
sim=Simulation()
run(sim)
#Collect stats - Global
# def collect(
#     animal: entities.Animal,
#     simulation: parameters.Simulation,
#     world
#     ):
    
#     simStats = results.SimulationStats()
#     popStats = results.PopulationStats()
#     allAnimals = world.get("animals")
#     allFoxes = []
#     allRabbits = []
#     allDeaths = []
    
#     ### populationStats for both rabbits and foxes are being collected ###
#     # splitting all animals into two seperate lists for foxes and rabbits
#     for animal in allAnimals:
#         if(type(animal) is entities.Rabbit):
#             allRabbits.append(animal)

#         if(type(animal) is entities.Fox):
#             allFoxes.append(animal)
            
#     ##          Global collections
#     #handles the collection of dead foxes and appends it to a list for dead animal
#     for foxes, rabbits in allFoxes, allRabbits:
#         if foxes.is_alive == False:
#             allDeaths.append(foxes, rabbits)

#         if  rabbits.is_alive == False:
#             allDeaths.append(foxes, rabbits)

#     #dead_at_starvation
#     for foxes, rabbits in allFoxes, allRabbits:
#         if foxes and simulation.max_energy <= 0:
#             popStats.dead_by_starvation.append(foxes)

#         if rabbits and simulation.max_energy <= 0:
#             popStats.dead_by_starvation.append(rabbits)

#     #age_at_death
#     for animal in allDeaths:
#         popStats.age_at_death.append(animal.age)

#     #total individuals that lives and lived once upon a time.
#     for animal in allRabbits, allFoxes, allDeaths:
#         if(type(animal) is entities.Animal.is_alive):
#             results.PopulationStats.total(animal)
        
#         if(type(animal) is entities.Fox.is_alive):
#             popStats.total(animal).extend(allDeaths)

#     ##          Individual collections
#     #death_by_predatation
#     if(type(animal) is entities.Rabbit.is_alive == False and entities.Rabbit.was_killed == True):
#         popStats.dead_by_predation.append(allDeaths.was_killed)

#     #size per step ######################################### Tick skal ordnes.
#     for animal in allAnimals:
#         if(type(animal) is entities.Fox and tick == 0 or simulation.foxes.max_energy[tick] == 0):
#             results.avg_energy_per_step.append(animal)
#         else:
#             results.avg_energy_per_step.append(round())

#         if(type(animal) is entities.Rabbit and tick == 0 or simulation.rabbits.max_energy == 0):
#             results.avg_energy_per_step.append(animal)
            
    ### simulationStats for both rabbits and foxes are being collected ###


    
    # #average energy per step
    # for animal in allAnimals:
    #     if(type(animal) is entities.Fox and tick == 0):
    #         pass
    #     if(type(animal) is entities.Rabbit and tick = 0):
    #         pass

    

#dead_by_old_age foxes, rabbits is alive was killed == false - ok
#dead_by_predation only rabbits, was killed == true - ok
#total len all animals - 




# This grid evolves over time in discrete steps: at each tick of the simulation clock
# animals move.
# feed.
# reproduce.
# and grass grows.




### Time Goes
## aging per tick - OK
## Energy spent - OK - tick


## animal movement
## Maturity - OK
## Feed - OK
## Safety from foxes

## make sure new babies don't move on first tick after being placed.
## pregnancy - ok

## is_alive - ok - hans funktioner håndterer dette intern i f.eks. entities.patch
## predators_in - ok
## same_species_in - ok
##
# Visualiser
## Batch
### start
### stop
### update
## ColourGraphics
### start
### stop
### update
## GrayscaleGraphics
### start
### stop
### update

# Results
## age_at_death
## ave_energy_per_step --> A record of the average energy level across all populations, in chronological order.
## dead_by_old_age
## dead_by_predation
## size_per_step
## total
## foxes PopulationStats
## rabbits PopulationStats
## kills_per_patch
## steps

# width = 40
# steps = parameters.execution.max_steps
# delay = parameters.execution.step_delay
# print(" [" + "simulation progress".center(width) + "]")
# print(" [", end="", flush=True)
# filled = 0
# for count in range(1, steps + 1):
#     time.sleep(delay)
#     x = int(round(width * count / steps))
#     if x - filled > 0:
#         print("-" * (x - filled), end="", flush=True)
#     filled = x
# print("] done", flush=True)

# # returns some dummy results
# return None
